"use strict";

/*
Copyright (c) 2016 Ram√≥n Baas

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/* 
  Alecto Protocol

  Only tested v3 with a WS-1100
  
*/

const utils = require('utils');

let v1, v3, v3c;

// Calculate simple Alecto v1 CRC
// See http://www.tfd.hu/tfdhu/files/wsprotocol/auriol_protocol_v20.pdf
function calcSimpleCRC(data) {
	let th = data[9] != 1 || data[10] != 1;
	let crc = (th ? 0xf : 0x7);
	for (let i = 0; i < 8; i++) {
		let val = Number(utils.bin2dec(data.slice(4 * i, 4 * (i + 1))));
		if (th) {
			crc -= val;
		} else {
			crc += val;
		}
	}
	return (crc & 0xf);
}

// CRC calculation for Alecto v2 & v3
// Taken from https://github.com/rinie/RFSniffer/blob/master/ScanDevices.ino
function calcAlectoCRC8(data) {
  let crc = 0;
  let x = 0;
  let len = data.length;
  // Indicated changes are from reference CRC-8 function in OneWire library
  while (len--) {
    let inbyte = data[x++];
    for (let i = 0; i < 8; i++) {
      let mix = (crc ^ inbyte) & 0x80; // changed from & 0x01
      crc = (crc << 1) & 0xff; // changed from right shift
      if (mix) {
			crc ^= 0x31;// changed from 0x8C;
	  }
      inbyte = (inbyte << 1) & 0xff; // changed from right shift
    }
  }
  return crc;
}

// Decode the received v1 data
function decodeAlectoV1(data) {
	let datastr = data.join('');
	let type = 'TH';
	if (datastr.slice(9, 11) === '11') {
		if (datastr.slice(12, 16) === '1100') {
			type = 'R';
		} else if (datastr.slice(12, 15) === '111' || datastr.slice(12, 24) === '100000000000') {
			type = 'W';
		}
	}
	let id = utils.bin2dec(data.slice(0, 8).reverse().join(''));
	let result = {
		id: id,
		type: type,
		data: { lowbattery: (data[8] == 1) }
	}
	// Decode the data based on the type
	if (type === 'TH') {
		//TODO: negative values
		let temperature = (utils.bin2dec(data.slice(12, 24).reverse().join('')) / 10).toFixed(1);
		let humidity = utils.bin2dec(data.slice(28, 32).reverse().join(''))
			+ utils.bin2dec(data.slice(24, 28).reverse().join(''))
		result.data.temperature = Number(temperature);
		result.data.humidity = Number(humidity);
		result.data.channel = Number(utils.bin2dec(data.slice(9, 11).reverse().join(''))) + 1;
	} else if (type === 'R') {
		let rain = utils.bin2dec(data.slice(16, 32).reverse().join(''));
		result.data.rainrate = rain * 0.25;
	} else if (type === 'W') {
		let val = utils.bin2dec(data.slice(24, 32).reverse().join('')) * 0.2;
		if (datastr.slice(12, 15) === '111') {
			result.data.direction = Number(utils.bin2dec(data.slice(15, 24).reverse().join('')));
			result.data.currentspeed = val;// gust
		} else {
			result.data.averagespeed = val;
		}
	}
	
	return result;
}

// Decode the received v3 data
function decodeAlectoV3(data) {
	let id = utils.bin2dec(data.slice(1, 9));
	let typeNr = Number(utils.bin2dec(data.slice(10, 12)));
	let result = {
		id: id,
		channel: Number(utils.bin2dec(data.slice(2, 4))) + 1,
		type: (typeNr == 4 ? 'R' : 'TH'),
		data: { lowbattery: (data[12] == '1') }
	}
	// Decode the data based on the type
	let temperature = (utils.bin2dec(data.slice(13, 24)) / 10 - 40).toFixed(1);
	if (typeNr != 4) { // Humidity (WS-1100)
		let humidity = utils.bin2dec(data.slice(24, 32));
		result.data.temperature = Number(temperature);
		result.data.humidity = Number(humidity);
	} else { // Rain sensor (WS-1200)
		let rain = utils.bin2dec(data.slice(32, 40)) * 256 + utils.bin2dec(data.slice(24, 32));
		result.data.temperature = Number(temperature);
		result.data.rainrate = rain * 0.3;
	}
	
	return result;
}

// Parse the data according to the Alecto v1 protocol
var parseAlectoV1 = function(payLoad) {
	let result = 'Not a valid Alecto message';
	v1.debug(payLoad.length, payLoad);
	let data = Array.prototype.slice.call(payLoad, 0);
	let decVal = '';
	for (let i = 0; i < data.length; i += 4) {
		decVal += (data.slice(i, i + 4)).reverse().join('');
	}
	v1.debug(decVal);
	let crc = calcSimpleCRC(decVal);
	let check = Number(utils.bin2dec(decVal.slice(32, 36)));
	if (crc === check) {
		result = decodeAlectoV1(data);
	} else {
		result = 'CRC error for Alecto v1 (' + crc + ' vs ' + check + ')';
	}
	
	return result;
}

// Parse the data according to the Alecto v3 protocol
var parseAlectoV3 = function(payLoad) {
	v3.debug(payLoad.length, payLoad);
	let result = 'Not a valid message';
	let crc, check;
	let decVal = payLoad.join('');
	let len = payLoad.length;
	if (decVal.slice(0, 8) === '11111110') { // assume bit 0 always 0
		// If the length is slightly longer than 47, see if it still contains a valid 47 message
		if (len > 47 && len < 50) {
			decVal = decVal.slice(0, 47)
		}
		// Remove first 7 values
		decVal = decVal.slice(7);
		len = decVal.length;
		let crcVals = [];
		for (let i = 0; i < (len >> 3) - 1; i++) {
			crcVals[i] = Number(utils.bin2dec(decVal.slice(8 * i, 8 * (i + 1))));
		}
		crc = calcAlectoCRC8(crcVals);
		check = Number(utils.bin2dec(decVal.slice(len - 8, len)));
		if (crc === check) {
			result = decodeAlectoV3(decVal);
		} else {
			result = 'CRC error (' + crc + ' vs ' + check + ')';
		}
	}
	return result;
}

module.exports = {
	init: () => {
		v1 = new utils.WeatherSignal({
			id: 'alectov1',
			name: 'Alecto v1',
			hint: { 
				en: 'No devices supported; for testing only',
				nl: 'Werkt nog niet, alleen voor testdoeleinden',
			},
			signal: 'AlectoV1',
			freq: 433,
			parser: parseAlectoV1
		});
		v3 = new utils.WeatherSignal({
			id: 'alectov3',
			name: 'Alecto v3',
			hint: {
				en: 'Supports Alecto WS-1100 & WS-1200',
				nl: 'Ondersteunt Alecto WS-1100/WS-1200'
			},
			signal: 'AlectoV3',
			freq: 433,
			parser: parseAlectoV3
		});
		v3c = new utils.WeatherSignal({
			id: 'conrad3',
			name: 'Conrad 868',
			hint: {
				en: 'Supports Conrad 868 MHz sensors',
				nl: 'Ondersteunt Conrad 868 MHz sensoren'
			},
			signal: 'Conrad',
			freq: 868,
			parser: parseAlectoV3
		});
	}
};
